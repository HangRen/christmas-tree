<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture 3D Countdown - 2026 Edition</title>
    <style>
        /* --- 基础样式 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* 深空黑 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: white;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* 隐藏视频元素，我们只需要数据 */
        .input_video {
            display: none;
        }

        /* --- UI 容器与玻璃拟态风格 --- */
        .ui-panel {
            position: absolute;
            z-index: 10;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        /* --- 顶部状态栏 --- */
        #status-bar {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
            text-align: center;
        }
        
        #status-bar.hidden {
            top: -150px;
        }

        .status-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 4px;
        }

        #current-gesture {
            font-size: 24px;
            font-weight: 600;
            background: linear-gradient(135deg, #fff 0%, #a5a5a5 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* --- 切换按钮 --- */
        #toggle-ui-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.3s;
        }
        #toggle-ui-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* --- 加载遮罩 --- */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* GUI 容器定位 */
        .lil-gui.root {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 11;
        }
        .hidden-gui {
            display: none !important;
        }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 20px; color: #888;">Initializing Vision & 3D Engine...</p>
        <p style="font-size: 12px; color: #555;">请允许摄像头权限</p>
    </div>

    <button id="toggle-ui-btn" title="Toggle UI">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>
    </button>

    <div id="status-bar" class="ui-panel">
        <div class="status-label">Detected Gesture</div>
        <div id="current-gesture">Waiting...</div>
        <div style="font-size: 10px; color: #555; margin-top:5px;">FPS: <span id="fps-counter">0</span></div>
    </div>

    <video class="input_video" playsinline></video>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import GUI from 'lil-gui';

        // --- 全局变量配置 ---
        const config = {
            particleCount: 3500,
            particleSize: 0.18,
            particleColor: '#ffffff',
            explosionColor: '#ffcc00',
            spread: 0.08, // 粒子随机抖动范围
            lerpSpeed: 0.08, // 变形速度
            bgColor: '#050505'
        };

        let scene, camera, renderer, particles, geometry;
        let targetPositions = []; // 目标形状的坐标数组
        let originalPositions = []; // 粒子当前位置
        let velocities = []; // 粒子速度（用于爆炸效果）
        let isExploding = false; // 是否处于爆炸状态
        let currentText = "";
        
        // 字体缓存
        let loadedFont = null;
        
        // 状态管理
        const state = {
            gesture: "None",
            display: "Waiting..."
        };

        // --- 1. Three.js 初始化 ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.bgColor);
            scene.fog = new THREE.FogExp2(config.bgColor, 0.03);

            // 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // 光照 (为了让粒子看起来更有体积感)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // 初始化粒子系统
            initParticles();

            // 监听窗口大小
            window.addEventListener('resize', onWindowResize);
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            const sizes = new Float32Array(config.particleCount);

            const color = new THREE.Color(config.particleColor);

            for (let i = 0; i < config.particleCount; i++) {
                // 初始随机分布
                positions[i * 3] = (Math.random() - 0.5) * 30;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 30;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 30;

                // 颜色
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                // 大小随机化
                sizes[i] = Math.random();

                // 初始化速度和目标
                targetPositions.push({x: 0, y: 0, z: 0});
                velocities.push({x: 0, y: 0, z: 0});
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // ShaderMaterial 用于更圆润漂亮的粒子
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: new THREE.TextureLoader().load( "https://threejs.org/examples/textures/sprites/spark1.png" ) },
                    baseSize: { value: config.particleSize * 200 } // 缩放因子
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float baseSize;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = baseSize * size * ( 300.0 / -mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( vColor, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        if ( gl_FragColor.a < 0.1 ) discard;
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // 初始生成 "READY" 字样
            loadFontAndGenerateText("READY");
        }

        // --- 2. 文本/形状生成逻辑 ---
        function loadFontAndGenerateText(textString, isExplosionMode = false) {
            if (currentText === textString && !isExplosionMode) return;
            currentText = textString;
            isExploding = isExplosionMode;

            // 恢复颜色 (如果之前是爆炸模式)
            const colors = geometry.attributes.color.array;
            const baseColor = new THREE.Color(config.particleColor);
            
            if (!isExploding) {
                for(let i=0; i<config.particleCount; i++) {
                    colors[i*3] = baseColor.r;
                    colors[i*3+1] = baseColor.g;
                    colors[i*3+2] = baseColor.b;
                }
                geometry.attributes.color.needsUpdate = true;
            }

            if (!loadedFont) {
                const loader = new FontLoader();
                // 使用 Three.js 示例字体 (无 CORS 问题)
                loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                    loadedFont = font;
                    generateTargetPoints(textString);
                });
            } else {
                generateTargetPoints(textString);
            }
        }

        function generateTargetPoints(text) {
            if (!loadedFont) return;

            const textGeo = new TextGeometry(text, {
                font: loadedFont,
                size: 3,
                height: 0.2,
                curveSegments: 12,
                bevelEnabled: false
            });

            textGeo.center();
            
            // 从几何体中采样点
            // 我们不直接使用顶点，因为顶点数量可能不够或分布不均
            // 这里使用简单的体积采样或表面采样模拟
            
            // 简化方案：如果粒子多于顶点，随机分布在顶点周围
            // 为了更好的效果，我们使用 Raycaster 或简单的顶点映射
            // 这里为了性能和单文件简洁性，直接映射顶点，不够的循环映射
            
            const positions = textGeo.attributes.position.array;
            const ptCount = positions.length / 3;

            for (let i = 0; i < config.particleCount; i++) {
                const index = i % ptCount;
                targetPositions[i] = {
                    x: positions[index * 3],
                    y: positions[index * 3 + 1],
                    z: positions[index * 3 + 2]
                };

                // 在爆炸模式下，给粒子一个随机的爆发速度
                if (isExploding) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.2 + Math.random() * 0.5;
                    velocities[i] = {
                        x: (Math.random() - 0.5) * speed * 2,
                        y: (Math.random() - 0.5) * speed * 2 + 0.5, // 向上趋势
                        z: (Math.random() - 0.5) * speed * 2
                    };
                    
                    // 爆炸颜色
                    const expColor = new THREE.Color().setHSL(Math.random(), 1.0, 0.6);
                    const colors = geometry.attributes.color.array;
                    colors[i*3] = expColor.r;
                    colors[i*3+1] = expColor.g;
                    colors[i*3+2] = expColor.b;
                }
            }
            if(isExploding) geometry.attributes.color.needsUpdate = true;
        }

        // --- 3. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const positions = geometry.attributes.position.array;

            if (isExploding) {
                // 爆炸物理模拟
                for (let i = 0; i < config.particleCount; i++) {
                    // 更新位置
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;

                    // 重力
                    velocities[i].y -= 0.01;
                    
                    // 阻力
                    velocities[i].x *= 0.98;
                    velocities[i].y *= 0.98;
                    velocities[i].z *= 0.98;
                }
            } else {
                // 文字变形 (Morphing)
                for (let i = 0; i < config.particleCount; i++) {
                    const target = targetPositions[i];
                    if(!target) continue;

                    const px = positions[i * 3];
                    const py = positions[i * 3 + 1];
                    const pz = positions[i * 3 + 2];

                    // 添加噪点，让粒子不是死板的静止
                    const noiseX = (Math.random() - 0.5) * config.spread;
                    const noiseY = (Math.random() - 0.5) * config.spread;
                    const noiseZ = (Math.random() - 0.5) * config.spread;

                    // Lerp 插值
                    positions[i * 3] += (target.x + noiseX - px) * config.lerpSpeed;
                    positions[i * 3 + 1] += (target.y + noiseY - py) * config.lerpSpeed;
                    positions[i * 3 + 2] += (target.z + noiseZ - pz) * config.lerpSpeed;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            
            // 缓慢旋转整个粒子群
            if(!isExploding) {
                particles.rotation.y += 0.002;
                particles.rotation.x = Math.sin(Date.now() * 0.001) * 0.1;
            }

            renderer.render(scene, camera);
            
            // Update FPS
            document.getElementById('fps-counter').innerText = Math.round(1000 / (performance.now() - lastTime));
            lastTime = performance.now();
        }
        let lastTime = 0;

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 4. MediaPipe 手势识别 ---
        function initMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];

            function onResults(results) {
                // 隐藏 Loader
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    detectGesture(landmarks);
                } else {
                    // 没有手的时候，保持当前状态或复位
                    // state.gesture = "None";
                }
            }

            // 动态加载 MediaPipe Hands (通过 CDN 引入的全局对象)
            // 注意：在实际生产中建议使用 npm imports，这里为了单文件使用了全局变量
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const cameraUtils = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start();
        }

        // 手势判断逻辑
        function detectGesture(landmarks) {
            // 简单的手指计数与形状判断
            const thumbTip = landmarks[4];
            const thumbIp = landmarks[3];
            const indexTip = landmarks[8];
            const indexPip = landmarks[6];
            const middleTip = landmarks[12];
            const middlePip = landmarks[10];
            const ringTip = landmarks[16];
            const ringPip = landmarks[14];
            const pinkyTip = landmarks[20];
            const pinkyPip = landmarks[18];

            // 判断手指伸展 (y 坐标越小越靠上)
            const isIndexOpen = indexTip.y < indexPip.y;
            const isMiddleOpen = middleTip.y < middlePip.y;
            const isRingOpen = ringTip.y < ringPip.y;
            const isPinkyOpen = pinkyTip.y < pinkyPip.y;
            
            // 拇指判断 (根据x轴相对位置，针对左右手可能不同，这里简化为相对掌心)
            // 简化：拇指 Tip x 距离 Pinky Base 较远则为张开
            const isThumbOpen = Math.abs(thumbTip.x - landmarks[17].x) > 0.2; 

            let count = 0;
            if (isIndexOpen) count++;
            if (isMiddleOpen) count++;
            if (isRingOpen) count++;
            if (isPinkyOpen) count++;
            if (isThumbOpen) count++;

            let newGesture = "";
            let displayText = "";
            let triggerExplosion = false;

            // 逻辑映射
            if (count === 5) {
                newGesture = "Open Palm";
                displayText = "5";
            } else if (count === 4) {
                newGesture = "Four";
                displayText = "4";
            } else if (count === 3) {
                newGesture = "Three";
                displayText = "3";
            } else if (count === 2) {
                newGesture = "Two";
                displayText = "2";
            } else if (count === 1 && isIndexOpen) {
                newGesture = "One";
                displayText = "1";
            } else if (count === 0) {
                // 握拳
                newGesture = "Fist";
                displayText = "新年好";
                triggerExplosion = true;
            } else if (count === 1 && isThumbOpen && !isIndexOpen) {
                // 点赞 (只有拇指)
                newGesture = "Thumbs Up";
                displayText = "READY\n2026";
            } else {
                // 其它过渡状态，保持上一个有效状态或忽略
                return;
            }

            // 更新 UI 和 3D 状态
            if (state.gesture !== newGesture) {
                state.gesture = newGesture;
                document.getElementById('current-gesture').innerText = newGesture;
                
                // 触发 3D 变化
                loadFontAndGenerateText(displayText, triggerExplosion);
            }
        }

        // --- 5. UI 与 控制 ---
        function initGUI() {
            const gui = new GUI({ title: 'Settings' });
            
            gui.add(config, 'particleSize', 0.05, 0.5).name('Particle Size').onChange(v => {
                 particles.material.uniforms.baseSize.value = v * 200;
            });
            
            gui.addColor(config, 'particleColor').name('Color').onChange(v => {
                if(!isExploding) {
                    const c = new THREE.Color(v);
                    const colors = geometry.attributes.color.array;
                    for(let i=0; i<config.particleCount; i++) {
                        colors[i*3] = c.r;
                        colors[i*3+1] = c.g;
                        colors[i*3+2] = c.b;
                    }
                    geometry.attributes.color.needsUpdate = true;
                }
            });

            gui.add(config, 'lerpSpeed', 0.01, 0.2).name('Morph Speed');
            gui.add(config, 'spread', 0, 0.5).name('Noise Amount');

            // UI 显隐逻辑
            const toggleBtn = document.getElementById('toggle-ui-btn');
            const statusBar = document.getElementById('status-bar');
            
            let uiVisible = true;
            toggleBtn.addEventListener('click', () => {
                uiVisible = !uiVisible;
                if(uiVisible) {
                    statusBar.classList.remove('hidden');
                    gui.domElement.classList.remove('hidden-gui');
                } else {
                    statusBar.classList.add('hidden');
                    gui.domElement.classList.add('hidden-gui');
                }
            });
        }

        // --- 启动 ---
        initThree();
        initGUI();
        initMediaPipe(); // 这会请求摄像头
        animate();

    </script>
</body>
</html>
